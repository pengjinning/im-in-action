= IM实战-IM In Action 草稿2
bytedesk(c) 2019 jackning
Version 2.0, 2019-06-19
:doctype: book
:icons: font
:source-highlighter: highlightjs
:sectnums:
:toc: left
:toclevels: 4
:toc-title: IM从0到1
:experimental:
:description: 基于Spring Boot/Netty/WebRTC构架即时通讯和在线客服系统
:keywords: 微服务 虾婆 SpringBoot Netty WebRTC Xiaper
:imagesdir: ./img
:sectlinks:

从零开始构建一套基于微服务的即时通讯和在线客服系统
http://www.iminaction.com

- 首先从IM传统实现方式开始讲解,对比各种开源框架(轮子),到自己动手从零实现一套即时通讯和在线客服系统(重新发明轮子)
- 本书侧重实战,提供了大量的实例源码,部分可直接用于生产环境


== 前言

- 传输方式和传输协议: 前端demo主要以javascript为主,服务器端demo主要以java为主. 
- 实战部分:
前端会包括:web/h5,android,ios,flutter,小程序, 服务端基于spring boot开发,开发语言以java为主



水平有限,难免有错误疏漏之处,敬请指出

== 传输方式 Transport

=== 轮询Http Polling

Ajax
JSONP


=== 捎带轮询Piggyback Polling


=== 长轮询Long Polling



接收消息越频繁,越接近于Http Polling

=== 流Http Streaming

iframe流

=== 反向Ajax

在一个标准的 HTTP Ajax 请求中，数据是从客户端发送给服务器端，反向 Ajax 可以某些特定的方式来模拟发出一个 Ajax 请求, 将数据从服务器端发送到客户端



=== SSE

Server-Send-Event

主要用于服务器向客户端广播或推送消息,而不需要任何交互,如新闻摘要/天气预报等

单向: server to client

参考:

- https://www.ruanyifeng.com/blog/2017/05/server-sent_events.html[Server-Sent Events 教程]

=== SPDY


=== 长连接Long-lived connection

长连接
tcp
全双工双向通信




=== Mars

Mars is a cross-platform network component developed by WeChat.

微信官方开源的跨平台网络组件

总的来说

- Mars 中包括一个完整的高性能的日志组件 xlog；
- Mars 中 STN 是一个跨平台的 socket 层解决方案，并不支持完整的 HTTP 协议；
- Mars 中 STN 模块是更加贴合“移动互联网”、“移动平台”特性的网络解决方案，尤其针对弱网络、平台特性等有很多的相关优化策略。
- Mars 是一个结合移动 App 所设计的基于 socket 层的解决方案，在网络调优方面有更好的可控性，不过对于 HTTP 完整协议的支持，已经考虑后续版本会加入。Mars在微信用的应用场景主要是：普通CGI请求类似收发消息收发语音，业务CGI支付请求等。

如果你想一次学习，多个平台使用，Mars 是一个比较好的选择，如果你面对的用户是移动网络下的用户，Mars 更是一个比较好的选择。但如果你只是想使用完整的 HTTP 协议，Mars暂时可能不适合你。如果你的应用中存在大量发送大数据的场景，Mars也不是一个好的选择，不建议使用。

=== 方案对比

对上述各种通信方式,以图表的形式对其各自优缺点进行对比




== 传输协议 Protocal

=== WebSocket

WebSocket是一种网络传输协议，可在单个TCP连接上进行全双工通信，位于OSI模型的应用层。WebSocket协议在2011年由IETF标准化为RFC 6455，后由RFC 7936补充规范。Web IDL中的WebSocket API由W3C标准化。

WebSocket使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。在WebSocket API中，浏览器和服务器只需要完成一次握手，两者之间就可以创建持久性的连接，并进行双向数据传输。

==== 简介
WebSocket是一种与HTTP不同的协议。两者都位于OSI模型的应用层，并且都依赖于传输层的TCP协议。 虽然它们不同，但RFC 6455规定：“WebSocket设计为通过80和443端口工作，以及支持HTTP代理和中介”，从而使其与HTTP协议兼容。 为了实现兼容性，WebSocket握手使用HTTP Upgrade头[1]从HTTP协议更改为WebSocket协议。

WebSocket协议支持Web浏览器（或其他客户端应用程序）与Web服务器之间的交互，具有较低的开销，便于实现客户端与服务器的实时数据传输。 服务器可以通过标准化的方式来实现，而无需客户端首先请求内容，并允许消息在保持连接打开的同时来回传递。通过这种方式，可以在客户端和服务器之间进行双向持续对话。 通信通过TCP端口80或443完成，这在防火墙阻止非Web网络连接的环境下是有益的。另外，Comet之类的技术以非标准化的方式实现了类似的双向通信。

大多数浏览器都支持该协议，包括Google Chrome、Firefox、Safari、Microsoft Edge、Internet Explorer和Opera。

与HTTP不同，WebSocket提供全双工通信。[2][3]此外，WebSocket还可以在TCP之上启用消息流。TCP单独处理字节流，没有固有的消息概念。 在WebSocket之前，使用Comet可以实现全双工通信。但是Comet存在TCP握手和HTTP头的开销，因此对于小消息来说效率很低。WebSocket协议旨在解决这些问题。

WebSocket协议规范将ws（WebSocket）和wss（WebSocket Secure）定义为两个新的统一资源标识符（URI）方案[4]，分别对应明文和加密连接。除了方案名称和片段ID（不支持#）之外，其余的URI组件都被定义为此URI的通用语法。[5]

使用浏览器开发人员工具，开发人员可以检查WebSocket握手以及WebSocket框架。[6]

==== 历史
WebSocket最初在HTML5规范中被引用为TCPConnection，作为基于TCP的套接字API的占位符。[7]2008年6月，Michael Carter进行了一系列讨论，最终形成了称为WebSocket的协议。[8]

“WebSocket”这个名字是Ian Hickson和Michael Carter之后在 #whatwg IRC聊天室创造的[9]，随后由Ian Hickson撰写并列入HTML5规范，并在Michael Carter的Cometdaily博客上宣布[10]。 2009年12月，Google Chrome 4是第一个提供标准支持的浏览器，默认情况下启用了WebSocket。[11]WebSocket协议的开发随后于2010年2月从W3C和WHATWG小组转移到IETF，并在Ian Hickson的指导下进行了两次修订。[12]

该协议被多个浏览器默认支持并启用后，RFC于2011年12月在Ian Fette下完成。[13]

==== 背景
现在，很多网站为了实现推送技术，所用的技术都是轮询。轮询是在特定的的时间间隔（如每秒），由浏览器对服务器发出HTTP请求，然后由服务器返回最新的数据给客户端的浏览器。这种传统的模式带来很明显的缺点，即浏览器需要不断的向服务器发出请求，然而HTTP请求可能包含较长的头部，其中真正有效的数据可能只是很小的一部分，显然这样会消耗很多的带宽资源。

比较新的轮询技术是Comet。这种技术虽然可以实现双向通信，但仍然需要反复发出请求。而且在Comet中普遍采用的HTTP长连接也会消耗服务器资源。

在这种情况下，HTML5定义了WebSocket协议，能更好的节省服务器资源和带宽，并且能够更实时地进行通讯。

Websocket使用ws或wss的统一资源标志符，类似于HTTPS。其中wss表示使用了TLS的Websocket。如：

ws://example.com/wsapi
wss://secure.example.com/wsapi
Websocket与HTTP和HTTPS使用相同的TCP端口，可以绕过大多数防火墙的限制。默认情况下，Websocket协议使用80端口；运行在TLS之上时，默认使用443端口。

==== 优点

- 较少的控制开销。在连接创建后，服务器和客户端之间交换数据时，用于协议控制的数据包头部相对较小。在不包含扩展的情况下，对于服务器到客户端的内容，此头部大小只有2至10字节（和数据包长度有关）；对于客户端到服务器的内容，此头部还需要加上额外的4字节的掩码。相对于HTTP请求每次都要携带完整的头部，此项开销显著减少了。
- 更强的实时性。由于协议是全双工的，所以服务器可以随时主动给客户端下发数据。相对于HTTP请求需要等待客户端发起请求服务端才能响应，延迟明显更少；即使是和Comet等类似的长轮询比较，其也能在短时间内更多次地传递数据。
- 保持连接状态。与HTTP不同的是，Websocket需要先创建连接，这就使得其成为一种有状态的协议，之后通信时可以省略部分状态信息。而HTTP请求可能需要在每个请求都携带状态信息（如身份认证等）。
更好的二进制支持。Websocket定义了二进制帧，相对HTTP，可以更轻松地处理二进制内容。
- 可以支持扩展。Websocket定义了扩展，用户可以扩展协议、实现部分自定义的子协议。如部分浏览器支持压缩等。
- 更好的压缩效果。相对于HTTP压缩，Websocket在适当的扩展支持下，可以沿用之前内容的上下文，在传递类似的数据时，可以显著地提高压缩率。[14]
握手协议
WebSocket 是独立的、创建在 TCP 上的协议。

Websocket 通过 HTTP/1.1 协议的101状态码进行握手。

为了创建Websocket连接，需要通过浏览器发出请求，之后服务器进行回应，这个过程通常称为“握手”（handshaking）。

==== 例子
一个典型的Websocket握手请求如下：

客户端请求

GET / HTTP/1.1
Upgrade: websocket
Connection: Upgrade
Host: example.com
Origin: http://example.com
Sec-WebSocket-Key: sN9cRrP/n9NdMgdcy2VJFQ==
Sec-WebSocket-Version: 13
服务器回应

HTTP/1.1 101 Switching Protocols
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Accept: fFBooB7FAkLlXgRSz0BT3v4hq5s=
Sec-WebSocket-Location: ws://example.com/
字段说明
Connection必须设置Upgrade，表示客户端希望连接升级。
Upgrade字段必须设置Websocket，表示希望升级到Websocket协议。
Sec-WebSocket-Key是随机的字符串，服务器端会用这些数据来构造出一个SHA-1的信息摘要。把“Sec-WebSocket-Key”加上一个特殊字符串“258EAFA5-E914-47DA-95CA-C5AB0DC85B11”，然后计算SHA-1摘要，之后进行BASE-64编码，将结果做为“Sec-WebSocket-Accept”头的值，返回给客户端。如此操作，可以尽量避免普通HTTP请求被误认为Websocket协议。
Sec-WebSocket-Version 表示支持的Websocket版本。RFC6455要求使用的版本是13，之前草案的版本均应当弃用。
Origin字段是可选的，通常用来表示在浏览器中发起此Websocket连接所在的页面，类似于Referer。但是，与Referer不同的是，Origin只包含了协议和主机名称。
其他一些定义在HTTP协议中的字段，如Cookie等，也可以在Websocket中使用。

https://zh.wikipedia.org/wiki/WebSocket[wiki]

而传统的轮询方式（即采用http协议不断发送请求）的缺点：

- 浪费流量（http请求头比较大）、
- 浪费资源（没有更新也要请求）、
- 消耗服务器CPU占用（没有信息也要接收请求）。

可以应用于

- 聊天
- 直播弹幕
- 游戏
- 股票行情
- 协作文档编辑

websocket完全是事件驱动的.也就是说,客户端不需要轮询服务器以得到目标资源的最新状态,只需要监听相关的通知即可.

websocket支持处理文本和二进制数据.

Websocket是消息协议/聊天/服务器通知/管道和多路复用协议/自定义协议/紧凑二进制协议和用于与互联网服务器互操作的其他标准协议的很好基础.

image::assets/img/tcp_http_websocket.png[]

- 持续连接(keep-alive)
- 心跳
- 网络状态检测
- 延迟测量



=== IRC

https://zh.wikipedia.org/wiki/IRC[wiki]

=== XMPP

https://zh.wikipedia.org/wiki/%E5%8F%AF%E6%89%A9%E5%B1%95%E6%B6%88%E6%81%AF%E4%B8%8E%E5%AD%98%E5%9C%A8%E5%8D%8F%E8%AE%AE[wiki]

=== STOMP

https://stomp.github.io/[website]

=== MQTT

https://zh.wikipedia.org/wiki/MQTT[wiki]

- websub

原名pubsubhubbub

- pubsub机制



=== 方案对比

对上述各种通信协议,以图表的形式对其各自优缺点进行对比,
得出结论使用websocket


== 框架 Framework

//=== Ejabberd

//smack/XMPPFramework/openfire/ejabberd

=== CometD

Cometd/Bayeux 协议




https://en.wikipedia.org/wiki/Comet_%28programming%29[wiki]

=== DWR

Direct Web Remoting


DWR supports Comet, Polling and Piggyback (sending data in with normal requests) as ways to publish to browsers.

参考:

- http://directwebremoting.org/dwr/index.html[Direct Web Remoting]


=== Atmosphere


=== Socket.io

=== SockJs

三种传输方式 WebSocket, HTTP Streaming, and HTTP Long Polling


https://spring.io/blog/2012/05/08/spring-mvc-3-2-preview-techniques-for-real-time-updates/[Techniques for Real-time Updates]



== 实战

私有协议

=== Netty

=== 建立长连接

(修路)

=== 传输协议

(定义交通规则)

=== 传输内容

(步行/自行车/机动车/装甲车)

- Json

- Protobuf

- 方案对比

对上述各种通信内容,以图表的形式对其各自优缺点进行对比,得出结论


=== 服务器Server

- webmvc 传统
- webflux 响应式 reactive


==== 一对一

文本
图片

==== 群聊

建群

==== 在线客服

工作组
指定坐席
统计

==== 机器人

- 第三方

=== 安卓Android

==== 一对一

文本
图片

==== 群聊

建群

==== 在线客服

工作组
指定坐席

==== 机器人

- 第三方

=== 苹果iOS

==== 一对一

文本
图片

==== 群聊

建群

==== 在线客服

工作组
指定坐席

==== 机器人

- 第三方

=== 网页Web/H5

==== 一对一

文本
图片

==== 群聊

建群

==== 在线客服

工作组
指定坐席

==== 机器人

- 第三方


=== Windows

- qt
- electron

==== 一对一

文本
图片

==== 群聊

建群

==== 在线客服

工作组
指定坐席

==== 机器人

- 第三方

=== Mac

- qt
- electron

==== 一对一

文本
图片

==== 群聊

建群

==== 在线客服

工作组
指定坐席

==== 机器人

- 第三方

=== 小程序

- 发文本
- 发图片

==== 一对一

文本
图片

==== 群聊

建群

==== 在线客服

工作组
指定坐席

==== 机器人

- 第三方

=== 跨平台Flutter


==== 一对一

文本
图片

==== 群聊

建群

==== 在线客服

工作组
指定坐席

==== 机器人

- 第三方


== 其他

=== 音视频

- webrtc

主要用于实时语音和视频聊天,可以用于传输数据.
可以结合webrtc和websocket构建实时应用

- 基本概念

- 应用

* 文本对话

* 实时音视频


=== 安全篇

- https/ssl

- 数据格式

* 文本传输
* 二进制
* protobuf

=== 加密

* 传输加密
* 存储加密
* 端到端加密

=== 压力测试

=== 对接第三方用户系统

=== 总体架构

=== 高性能

=== 高可用


== 参考

- signal
- telegram
- mars
- mixin







